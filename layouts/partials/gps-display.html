{{ if .Params.gps }}
{{ $gpxFile := .Resources.Get .Params.gps }}
<br>
<div id="map-container">
    <div id="loading">
        <div class="spinner"></div>
        <div class="loading-text">
            <p>Chargement de la carte...</p>
        </div>
    </div>
    <div class="fade-hidden">
        <div id="map"></div>
        <div id="elevation-chart-container">
            <canvas id="elevation-chart"></canvas>
        </div>
        <br>
        <div class="level" id="stats">
            <div class="level-item has-text-centered">
                <div>
                    <p class="heading">Distance</p>
                    <p id="distance" class="subtitle"></p>
                </div>
            </div>
            <div class="level-item has-text-centered">
                <div>
                    <p class="heading">Durée</p>
                    <p id="duree" class="subtitle"></p>
                </div>
            </div>
            <div class="level-item has-text-centered">
                <div>
                    <p class="heading">Dénivelé</p>
                    <p id="denivele" class="subtitle"></p>
                </div>
            </div>
            <div class="level-item has-text-centered">
                <div>
                    <p class="heading">Vitesse</p>
                    <p id="vitesse" class="subtitle"></p>
                </div>
            </div>
        </div>
    </div>
</div>

{{ with $gpxFile }}
<script type="module">
    const spinner = document.getElementById('loading');
    const map = L.map('map');

    // Fonction utilitaire pour le fade-in
    const fadeIn = (element) => {
        element.classList.remove('fade-hidden');
        element.classList.add('fade-visible');
    };

    // Fonction pour convertir les millisecondes en HH:MM:SS
    const formatTime = (milliseconds) => {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${hours.toString().padStart(2, '0')}h ${minutes.toString().padStart(2, '0')}m ${seconds.toString().padStart(2, '0')}s`;
    };

    L.tileLayer("https://services.arcgisonline.com/arcgis/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}.png", {
        attribution: 'Map data &copy; <a href="http://www.osm.org">OpenStreetMap</a>'
    }).addTo(map);

    const url = "{{ .RelPermalink }}";
    const options = {
        async: true,
        polyline_options: { color: "var(--gpx-color)" },
        markers: {
            startIcon: null,
            endIcon: null,
        }
    };

    const gpx = new L.GPX(url, options).on('loaded', (e) => {
        // Créer un formateur de nombres pour le français
        const formatter = new Intl.NumberFormat('fr-FR', {
            maximumFractionDigits: 1,
            minimumFractionDigits: 0
        });

        map.fitBounds(e.target.getBounds());
        spinner.classList.add('hidden');
        document.querySelectorAll('.fade-hidden').forEach((el) => {
            fadeIn(el);
        });

        // Formatter et assigner les valeurs
        document.getElementById("distance").textContent = formatter.format(e.target.get_distance() / 1000) + ' km';
        document.getElementById("duree").textContent = formatTime(e.target.get_moving_time());
        document.getElementById("denivele").textContent = formatter.format(e.target.get_elevation_gain()) + ' m';
        document.getElementById("vitesse").textContent = formatter.format(e.target.get_moving_speed()) + ' km/h';

        // Récupérer les données d'élévation
        const points = e.target.get_elevation_data();
        const data = points.map(p => ({
            distance: p[0],
            elevation: p[1]
        }));

        // Créer le graphique
        const ctx = document.getElementById('elevation-chart').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.map(p => p.distance.toFixed(1)),
                datasets: [{
                    label: 'Altitude (m)',
                    data: data.map(p => p.elevation),
                    fill: true,
                    backgroundColor: "lightblue",
                    showLine: false,
                }]
            },
            options: {
                elements: {
                    point: {
                        radius: 0
                    }
                },
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: 0
                },
                animation: false,
                scales: {

                    x: {
                        title: {
                            display: false,
                            text: 'Distance (km)'
                        }
                    },
                    y: {
                        title: {
                            display: false,
                            text: 'Altitude (m)'
                        }
                    }
                },
                onHover: (event, elements) => {
                    if (elements.length) {
                        const index = elements[0].index;
                        const point = track.getLatLngs()[index];
                        hoverMarker.setLatLng(point);
                        hoverMarker.setStyle({ opacity: 1 });

                        chart.setActiveElements([{
                            datasetIndex: 0,
                            index: index
                        }]);
                        chart.update('none');
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(255, 255, 255, 0.9)',
                        titleColor: '#666',
                        bodyColor: '#666',
                        titleFont: {
                            weight: 'bold',
                            size: 14
                        },
                        bodyFont: {
                            size: 13
                        },
                        padding: 10,
                        borderColor: '#ddd',
                        borderWidth: 1,
                        displayColors: false,
                        position: 'nearest',
                        caretPadding: 20,  // Distance en pixels entre le curseur et le tooltip
                        caretSize: 3,      // Taille de la flèche du tooltip
                        callbacks: {
                            title: () => 'Point du parcours',
                            label: (context) => {
                                const elevation = data[context.dataIndex].elevation;
                                const distance = data[context.dataIndex].distance;
                                return [
                                    `Distance: ${formatter.format(distance)} km`,
                                    `Altitude: ${formatter.format(elevation)} m`
                                ];
                            }
                        }
                    }
                }
            }
        });
        // Créer un marqueur caché qui sera réutilisé
        const hoverMarker = L.circleMarker([0, 0], {
            radius: 6,
            color: 'white',
            fillColor: 'lightblue',
            fillOpacity: 1,
            weight: 2,
            opacity: 0,
        }).addTo(map);

        // Récupérer le tracé GPX
        const track = e.target.getLayers()[0];

        // Fonction pour trouver l'index du point le plus proche
        const findClosestPointIndex = (latlng) => {
            const points = track.getLatLngs();
            const p = map.latLngToLayerPoint(latlng);
            return points.findIndex((point) => {
                const p2 = map.latLngToLayerPoint(point);
                const dist = p.distanceTo(p2);
                if (dist < 20) {
                    return point;
                }
            });
        };

        // Déplacer les événements sur la ligne d'interaction
        gpx.on('mousemove', (e) => {
            const index = findClosestPointIndex(e.latlng);
            const point = track.getLatLngs()[index];
            hoverMarker.setLatLng(point);
            hoverMarker.setStyle({ opacity: 1 });
            chart.setActiveElements([{
                datasetIndex: 0,
                index: index
            }]);
            chart.update('none');
        });
    }).addTo(map);

</script>
{{end}}
<hr>
{{ else }}
<br>
{{ end }}